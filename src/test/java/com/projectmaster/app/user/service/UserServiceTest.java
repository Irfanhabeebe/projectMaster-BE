package com.projectmaster.app.user.service;

import com.projectmaster.app.common.enums.UserRole;
import com.projectmaster.app.config.PasswordConfig.SimplePasswordEncoder;
import com.projectmaster.app.security.service.CustomUserDetailsService;
import com.projectmaster.app.user.dto.CreateUserRequest;
import com.projectmaster.app.user.dto.UserDto;
import com.projectmaster.app.company.entity.Company;
import com.projectmaster.app.user.entity.User;
import com.projectmaster.app.company.repository.CompanyRepository;
import com.projectmaster.app.user.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.Authentication;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private CompanyRepository companyRepository;

    @Mock
    private SimplePasswordEncoder passwordEncoder;

    @Mock
    private Authentication authentication;

    @Mock
    private CustomUserDetailsService.CustomUserPrincipal userPrincipal;

    @InjectMocks
    private UserService userService;

    private Company testCompany;
    private User currentUser;
    private CreateUserRequest createUserRequest;

    @BeforeEach
    void setUp() {
        testCompany = Company.builder()
                .name("Test Company")
                .active(true)
                .build();
        // Set the ID manually since it's generated by the database
        testCompany.setId(UUID.randomUUID());

        currentUser = User.builder()
                .email("current@test.com")
                .company(testCompany)
                .role(UserRole.ADMIN)
                .active(true)
                .build();
        // Set the ID manually since it's generated by the database
        currentUser.setId(UUID.randomUUID());

        createUserRequest = CreateUserRequest.builder()
                .email("newuser@test.com")
                .firstName("New")
                .lastName("User")
                .phone("123-456-7890")
                .role(UserRole.TRADIE)
                .password("password123")
                .build();
    }

    @Test
    void createUser_WithCompanyId_ShouldUseProvidedCompany() {
        // Arrange
        createUserRequest.setCompanyId(testCompany.getId());
        when(userRepository.existsByEmailIgnoreCase(any())).thenReturn(false);
        when(companyRepository.findById(testCompany.getId())).thenReturn(Optional.of(testCompany));
        when(passwordEncoder.encode(any())).thenReturn("encodedPassword");
        when(userRepository.save(any())).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(UUID.randomUUID());
            return user;
        });

        // Act
        UserDto result = userService.createUser(createUserRequest, authentication);

        // Assert
        assertNotNull(result);
        assertEquals(testCompany.getId(), result.getCompanyId());
        assertEquals(testCompany.getName(), result.getCompanyName());
        verify(companyRepository).findById(testCompany.getId());
    }

    @Test
    void createUser_WithoutCompanyId_ShouldUseCurrentUserCompany() {
        // Arrange
        when(userRepository.existsByEmailIgnoreCase(any())).thenReturn(false);
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);
        when(passwordEncoder.encode(any())).thenReturn("encodedPassword");
        when(userRepository.save(any())).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(UUID.randomUUID());
            return user;
        });

        // Act
        UserDto result = userService.createUser(createUserRequest, authentication);

        // Assert
        assertNotNull(result);
        assertEquals(testCompany.getId(), result.getCompanyId());
        assertEquals(testCompany.getName(), result.getCompanyName());
        verify(companyRepository, never()).findById(any());
    }

    @Test
    void createUser_SuperUser_ShouldNotHaveCompany() {
        // Arrange
        createUserRequest.setRole(UserRole.SUPER_USER);
        when(userRepository.existsByEmailIgnoreCase(any())).thenReturn(false);
        when(passwordEncoder.encode(any())).thenReturn("encodedPassword");
        when(userRepository.save(any())).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(UUID.randomUUID());
            return user;
        });

        // Act
        UserDto result = userService.createUser(createUserRequest, authentication);

        // Assert
        assertNotNull(result);
        assertNull(result.getCompanyId());
        assertNull(result.getCompanyName());
        verify(companyRepository, never()).findById(any());
    }

    @Test
    void createUser_WithoutCompanyIdAndNoCurrentUserCompany_ShouldThrowException() {
        // Arrange
        currentUser.setCompany(null);
        when(userRepository.existsByEmailIgnoreCase(any())).thenReturn(false);
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);

        // Act & Assert
        assertThrows(RuntimeException.class, () -> 
            userService.createUser(createUserRequest, authentication));
    }

    @Test
    void createUser_InternalCall_ShouldRequireCompanyId() {
        // Arrange
        when(userRepository.existsByEmailIgnoreCase(any())).thenReturn(false);

        // Act & Assert
        assertThrows(RuntimeException.class, () -> 
            userService.createUser(createUserRequest));
    }

    @Test
    void createUser_InternalCall_WithCompanyId_ShouldSucceed() {
        // Arrange
        createUserRequest.setCompanyId(testCompany.getId());
        when(userRepository.existsByEmailIgnoreCase(any())).thenReturn(false);
        when(companyRepository.findById(testCompany.getId())).thenReturn(Optional.of(testCompany));
        when(passwordEncoder.encode(any())).thenReturn("encodedPassword");
        when(userRepository.save(any())).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(UUID.randomUUID());
            return user;
        });

        // Act
        UserDto result = userService.createUser(createUserRequest);

        // Assert
        assertNotNull(result);
        assertEquals(testCompany.getId(), result.getCompanyId());
        assertEquals(testCompany.getName(), result.getCompanyName());
    }

    @Test
    void getActiveUsersByAuthentication_SuperUser_ShouldReturnAllUsers() {
        // Arrange
        currentUser.setRole(UserRole.SUPER_USER);
        currentUser.setCompany(null);
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);
        when(userRepository.findAllActiveUsersAcrossCompanies()).thenReturn(List.of(currentUser));

        // Act
        List<UserDto> result = userService.getActiveUsersByAuthentication(authentication);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.size());
        verify(userRepository).findAllActiveUsersAcrossCompanies();
    }

    @Test
    void getActiveUsersByAuthentication_RegularUser_ShouldReturnCompanyUsers() {
        // Arrange
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);
        when(userRepository.findByCompanyIdAndActiveTrue(testCompany.getId())).thenReturn(List.of(currentUser));

        // Act
        List<UserDto> result = userService.getActiveUsersByAuthentication(authentication);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.size());
        verify(userRepository).findByCompanyIdAndActiveTrue(testCompany.getId());
    }

    @Test
    void getActiveUsersByAuthentication_UserWithoutCompany_ShouldThrowException() {
        // Arrange
        currentUser.setCompany(null);
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);

        // Act & Assert
        assertThrows(RuntimeException.class, () -> 
            userService.getActiveUsersByAuthentication(authentication));
    }

    @Test
    void searchUsersByAuthentication_SuperUser_ShouldReturnEmptyPage() {
        // Arrange
        currentUser.setRole(UserRole.SUPER_USER);
        currentUser.setCompany(null);
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);

        // Act
        Page<UserDto> result = userService.searchUsersByAuthentication("test", Pageable.unpaged(), authentication);

        // Assert
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void searchUsersByAuthentication_RegularUser_ShouldReturnCompanyUsers() {
        // Arrange
        when(authentication.getPrincipal()).thenReturn(userPrincipal);
        when(userPrincipal.getUser()).thenReturn(currentUser);
        when(userRepository.findByCompanyIdAndSearchTerm(testCompany.getId(), "test")).thenReturn(List.of(currentUser));

        // Act
        Page<UserDto> result = userService.searchUsersByAuthentication("test", Pageable.unpaged(), authentication);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(userRepository).findByCompanyIdAndSearchTerm(testCompany.getId(), "test");
    }
}
